//go:build ignore

// To run: go run generate.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/samber/lo"
)

type Options struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
	Default     any      `json:"default"`
	Type        string   `json:"type"`
	Choices     string   `json:"choices"`
}
type Args struct {
	Name    string `json:"name"`
	Type    string `json:"type"`
	Choices any    `json:"choices"`
}
type Combined struct {
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Usage       string    `json:"usage"`
	Options     []Options `json:"options"`
	Args        []Args    `json:"args"`
}

func main() {
	jsonData, err := os.ReadFile("combined_calibredb_options.json")
	if err != nil {
		panic(err)
	}

	// unmarshal jsonData into map[string]Combined
	combined := make(map[string]Combined)
	err = json.Unmarshal(jsonData, &combined)
	if err != nil {
		panic(err)
	}

	for name, cmd := range combined {
		var out bytes.Buffer
		name = strings.Replace(name, "cmd_", "", 1)
		pascalCmd := lo.PascalCase(name)
		structName := pascalCmd + "Options"

		fmt.Println("Processing Command:", name)

		out.WriteString("// Code generated by generate.go; DO NOT EDIT.\n")
		out.WriteString("//\n// Command:\n")
		for line := range strings.SplitSeq(cmd.Usage, "\n") {
			out.WriteString("// " + line + "\n")
		}
		out.WriteString("//\n// Description:\n")
		for line := range strings.SplitSeq(cmd.Description, "\n") {
			out.WriteString("// " + line + "\n")
		}
		out.WriteString("\n")
		out.WriteString("package calibredb\n\n")

		// we need to check if we have any float or int types
		needsFmt := false
		for _, option := range cmd.Options {
			if option.Type == "float" || option.Type == "int" {
				needsFmt = true
				break
			}
		}
		if needsFmt {
			out.WriteString("import (\n\t\"fmt\"\n)\n\n")
		}

		fmt.Println("--Generating struct", structName)
		out.WriteString("type " + structName + " struct {\n")
		choices := make(map[string]string)

		if len(cmd.Args) > 0 {
			out.WriteString("\t// Command Line Arguments\n")
			for _, arg := range cmd.Args {
				fieldName := lo.PascalCase(arg.Name)
				argType := arg.Type
				if argType == "bool" {
					argType = "*bool"
				}
				out.WriteString(fmt.Sprintf("\t%s %s  `validate:\"required\"`\n", fieldName, argType))
			}
		}

		if len(cmd.Options) > 0 {
			out.WriteString("\n\t// Command Line Options\n")

			for _, option := range cmd.Options {
				if len(option.Names) == 0 {
					continue
				}
				columnName := loadColumnName(option)
				fieldName := lo.PascalCase(strings.TrimLeft(columnName, "-"))

				var fieldType string
				switch option.Type {
				case "string":
					fieldType = "string"
				case "[]string":
					fieldType = "[]string"
				case "int":
					fieldType = "int"
				case "float":
					fieldType = "float64"
				case "bool":
					fieldType = "*bool"
				case "choice":
					fieldType = fmt.Sprintf("%sChoice", fieldName)
					choices[fieldType] = option.Choices
				default:
					panic("unknown type: " + option.Type)
					fieldType = "string"
				}
				out.WriteString(fmt.Sprintf("\t%s %s  // %s\n", fieldName, fieldType, strings.ReplaceAll(option.Description, "\n", " ")))
			}
		}
		out.WriteString("}\n")

		// generate choice types
		if len(choices) > 0 {
			for choiceType, choiceValues := range choices {
				out.WriteString("\n")
				out.WriteString(fmt.Sprintf("type %s string\n\n", choiceType))
				out.WriteString("const (\n")
				// parse choiceValues which is in format "('disabled', 'ignore', 'overwrite', 'new_record')"
				trimmed := strings.Trim(choiceValues, "()")
				split := strings.Split(trimmed, ",")
				for _, val := range split {
					cleaned := strings.Trim(val, " '\"")
					if cleaned == "" {
						continue
					}
					constName := lo.PascalCase(cleaned)
					out.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, choiceType, cleaned))
				}
				out.WriteString(")\n")
			}
		}
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "Help() string {\n")
		out.WriteString(fmt.Sprintf("\tif out, err := c.run(\"%s\", \"-h\"); err != nil {\n", name))
		out.WriteString("\t\treturn err.Error()\n")
		out.WriteString("\t} else {\n")
		out.WriteString("\t\treturn out\n")
		out.WriteString("\t}\n")
		out.WriteString("}\n")
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "(opts " + structName + ", args ...string) (string, error) {\n")
		out.WriteString(fmt.Sprintf("\targv := []string{\"%s\"}\n\n", name))
		out.WriteString("\t// validate the command line arguments\n")
		out.WriteString("\terr := c.validate.Struct(opts)\n")
		out.WriteString("\tif err != nil {\n")
		out.WriteString("\t\treturn \"\", err\n")
		out.WriteString("\t}\n")

		if len(cmd.Args) > 0 {
			out.WriteString("\t// Command Line Arguments\n")
			for _, arg := range cmd.Args {
				fieldName := lo.PascalCase(arg.Name)

				switch arg.Type {
				case "string":
					out.WriteString(fmt.Sprintf("\targv = append(argv, opts.%s)\n", fieldName))
				case "[]string":
					out.WriteString(fmt.Sprintf("\targv = append(argv, opts.%s...)\n", fieldName))
				}
			}
		}
		if len(cmd.Options) > 0 {
			out.WriteString("\n\t// Command Line Options\n")
			for _, option := range cmd.Options {
				if len(option.Names) == 0 {
					continue
				}
				columnName := loadColumnName(option)
				fieldName := lo.PascalCase(strings.TrimLeft(columnName, "-"))

				switch option.Type {
				case "string":
					out.WriteString("\t// Handling string\n")
					out.WriteString(fmt.Sprintf("\tif opts.%s != \"\" {\n", fieldName))
					out.WriteString(fmt.Sprintf("\t\targv = append(argv, \"%s\", opts.%s)\n", columnName, fieldName))
					out.WriteString("\t}\n")
				case "[]string":
					out.WriteString("\t// Handling []string\n")
					out.WriteString(fmt.Sprintf("\tif len(opts.%s) > 0 {\n", fieldName))
					out.WriteString(fmt.Sprintf("\t\targv = append(argv, \"%s\")\n", columnName))
					out.WriteString(fmt.Sprintf("\t\targv = append(argv, opts.%s...)\n", fieldName))
					out.WriteString("\t}\n")
				case "bool":
					out.WriteString("\t// Handling bool\n")
					out.WriteString(fmt.Sprintf("\tif opts.%s != nil && *opts.%s {\n", fieldName, fieldName))
					out.WriteString(fmt.Sprintf("\t\targv = append(argv, \"%s\")\n", columnName))
					out.WriteString("\t}\n")
				case "float":
					out.WriteString("\t// Handling float\n")
					out.WriteString(fmt.Sprintf("\tif opts.%s != 0 {\n", fieldName))
					out.WriteString(fmt.Sprintf("\t\targv = append(argv, \"%s\", fmt.Sprint(opts.%s))\n", columnName, fieldName))
					out.WriteString("\t}\n")
				case "int":
					out.WriteString("\t// Handling int\n")
					out.WriteString(fmt.Sprintf("\tif opts.%s != 0 {\n", fieldName))
					out.WriteString(fmt.Sprintf("\t\targv = append(argv, \"%s\", fmt.Sprint(opts.%s))\n", columnName, fieldName))
					out.WriteString("\t}\n")
				case "choice":
					out.WriteString("\t// Handling choice\n")
					out.WriteString(fmt.Sprintf("\tif opts.%s != \"\" {\n", fieldName))
					out.WriteString(fmt.Sprintf("\t\targv = append(argv, \"%s\", string(opts.%s))\n", columnName, fieldName))
					out.WriteString("\t}\n")
				default:
					panic("unhandled option type: " + option.Type)
					out.WriteString(fmt.Sprintf("\t// Handling other %s\n", option.Type))
					// out.WriteString(fmt.Sprintf("\tif opts.%s != nil {\n", fieldName))
					// out.WriteString(fmt.Sprintf("\t\targv = append(argv, \"%s\", fmt.Sprint(opts.%s))\n", columnName, fieldName))
					// out.WriteString("\t}\n")
				}
			}
		}

		out.WriteString("\tout, err := c.run(argv...)\n")
		out.WriteString("\treturn out, err\n")
		out.WriteString("}\n")

		err = os.WriteFile(fmt.Sprintf("calibredb/%s.go", name), out.Bytes(), 0644)
		if err != nil {
			panic(err)
		}
	}
}

func loadColumnName(option Options) string {
	var columnName string
	flags := option.Names
	if len(flags) == 0 {
		return columnName
	}
	// if there is more than one flag, prefer the long one
	if len(flags) > 1 {
		for _, flag := range flags {
			if strings.HasPrefix(flag, "--") {
				columnName = flag
				break
			}
		}
	} else if len(flags) == 1 {
		columnName = flags[0]
	}
	return columnName
}
