//go:build ignore

// To run: go run generate.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/samber/lo"
	"github.com/veverkap/calibre-rest/calibredb"
)

type Options struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
	Default     any      `json:"default"`
	Type        string   `json:"type"`
	Choices     string   `json:"choices"`
}
type Args struct {
	Name    string `json:"name"`
	Type    string `json:"type"`
	Choices any    `json:"choices"`
}
type Combined struct {
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Usage       string    `json:"usage"`
	Options     []Options `json:"options"`
	Args        []Args    `json:"args"`
}

func main() {
	c := calibredb.NewCalibre(calibredb.WithLibraryPath("/Users/veverkap/Code/personal/calibre-rest"))
	output, err := c.AddCustomColumn(
		calibredb.AddCustomColumnOptions{
			Label:    "sdfassaddafsdsdfdsfsd",
			Name:     "My Column",
			Datatype: "text",
		},
	)
	fmt.Println(output, err)
	os.Exit(1)
	jsonData, err := os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/combined_calibredb_options.json")
	if err != nil {
		panic(err)
	}

	// unmarshal jsonData into map[string]Combined
	combined := make(map[string]Combined)
	err = json.Unmarshal(jsonData, &combined)
	if err != nil {
		panic(err)
	}

	for name, cmd := range combined {
		var out bytes.Buffer
		name = strings.Replace(name, "cmd_", "", 1)
		// fmt.Println("Processing Command:", name)
		pascalCmd := lo.PascalCase(name)
		structName := pascalCmd + "Options"
		// fmt.Println("--Generating struct", structName)
		out.WriteString("// Code generated by generate.go; DO NOT EDIT.\n")
		out.WriteString("//\n// Command:\n")
		for line := range strings.SplitSeq(cmd.Usage, "\n") {
			out.WriteString("// " + line + "\n")
		}
		out.WriteString("//\n// Description:\n")
		for line := range strings.SplitSeq(cmd.Description, "\n") {
			out.WriteString("// " + line + "\n")
		}
		out.WriteString("\n")
		out.WriteString("package calibredb\n\n")
		// out.WriteString("import (\n\t\"fmt\"\n)\n\n")
		out.WriteString("type " + structName + " struct {\n")
		choices := make(map[string]string)

		if len(cmd.Args) > 0 {
			out.WriteString("\t// Command Line Arguments\n")
			for _, arg := range cmd.Args {
				fieldName := lo.PascalCase(arg.Name)
				argType := arg.Type
				if argType == "bool" {
					argType = "*bool"
				}
				out.WriteString(fmt.Sprintf("\t%s %s  `validate:\"required\"`\n", fieldName, argType))
			}
		}

		if len(cmd.Options) > 0 {
			out.WriteString("\n\t// Command Line Options\n")

			for _, option := range cmd.Options {
				if len(option.Names) == 0 {
					continue
				}
				columnName := loadColumnName(option)
				fieldName := lo.PascalCase(strings.TrimLeft(columnName, "-"))

				var fieldType string
				switch option.Type {
				case "string":
					fieldType = "string"
				case "int":
					fieldType = "int"
				case "float":
					fieldType = "float64"
				case "bool":
					fieldType = "*bool"
				case "choice":
					fieldType = fmt.Sprintf("%sChoice", fieldName)
					choices[fieldType] = option.Choices
				default:
					fieldType = "string"
				}
				// fmt.Printf("----Field: %s Type: %s\n", fieldName, fieldType)
				out.WriteString(fmt.Sprintf("\t%s %s  // %s\n", fieldName, fieldType, strings.ReplaceAll(option.Description, "\n", " ")))
			}
		}
		out.WriteString("}\n")

		// generate choice types
		if len(choices) > 0 {
			for choiceType, choiceValues := range choices {
				out.WriteString("\n")
				out.WriteString(fmt.Sprintf("type %s string\n\n", choiceType))
				out.WriteString("const (\n")
				// parse choiceValues which is in format "('disabled', 'ignore', 'overwrite', 'new_record')"
				trimmed := strings.Trim(choiceValues, "()")
				split := strings.Split(trimmed, ",")
				for _, val := range split {
					cleaned := strings.Trim(val, " '\"")
					if cleaned == "" {
						continue
					}
					constName := lo.PascalCase(cleaned)
					out.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, choiceType, cleaned))
				}
				out.WriteString(")\n")
			}
		}
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "Help() string {\n")
		out.WriteString(fmt.Sprintf("\tif out, err := c.run(\"%s\", \"-h\"); err != nil {\n", name))
		out.WriteString("\t\treturn err.Error()\n")
		out.WriteString("\t} else {\n")
		out.WriteString("\t\treturn out\n")
		out.WriteString("\t}\n")
		out.WriteString("}\n")
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "(opts " + structName + ", args ...string) (string, error) {\n")
		out.WriteString(fmt.Sprintf("\targv := []string{\"%s\"}\n\n", name))
		out.WriteString("\t// validate the command line arguments\n")
		out.WriteString("\terr := c.validate.Struct(opts)\n")
		out.WriteString("\tif err != nil {\n")
		out.WriteString("\t\treturn \"\", err\n")
		out.WriteString("\t}\n")

		if len(cmd.Args) > 0 {
			out.WriteString("\t// Command Line Arguments\n")
			for _, arg := range cmd.Args {
				fieldName := lo.PascalCase(arg.Name)

				switch arg.Type {
				case "string":
					out.WriteString(fmt.Sprintf("\targv = append(argv, opts.%s)\n", fieldName))
				case "[]string":
					out.WriteString(fmt.Sprintf("\targv = append(argv, opts.%s...)\n", fieldName))
				}
			}
		}

		out.WriteString("\tout, err := c.run(argv...)\n")
		out.WriteString("\treturn out, err\n")
		out.WriteString("}\n")

		err = os.WriteFile(fmt.Sprintf("calibredb/%s.go", name), out.Bytes(), 0644)
		if err != nil {
			panic(err)
		}
	}
}

// func test() {
// 	c := calibredb.NewCalibre(calibredb.WithLibraryPath("/Users/veverkap/Code/personal/calibre-rest"))

// 	s := c.List(
// 		calibredb.ListOptions{
// 			Ascending:  true,
// 			Fields:     "author_sort, authors, comments",
// 			ForMachine: lo.ToPtr(false),
// 			Limit:      2,
// 		},
// 	)
// 	fmt.Println(s)
// }

// func generate() {
// 	// read calibre_cli_options.json
// 	jsonData, err := os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/calibredb_cli_options.json")
// 	if err != nil {
// 		panic(err)
// 	}
// 	// unmarshal jsonData into map[string]Command
// 	commands := make(map[string]Command)
// 	err = json.Unmarshal(jsonData, &commands)
// 	if err != nil {
// 		panic(err)
// 	}

// 	for _, cmd := range commands {
// 		for i, option := range cmd.Options {
// 			if option.Type == "" {
// 				switch option.Default.(type) {
// 				case string:
// 					option.Type = "string"
// 				case int:
// 					option.Type = "int"
// 				case bool:
// 					option.Type = "bool"
// 				case float64:
// 					option.Type = "float"
// 				default:
// 					option.Type = "string"
// 				}
// 			}
// 			cmd.Options[i] = option
// 		}
// 	}

// 	// name := "cmd_add"
// 	// cmd := commands[name]
// 	for name, cmd := range commands {
// 		var out bytes.Buffer
// 		fmt.Println("Processing ", name)

// 		name = strings.Replace(name, "cmd_", "", 1)
// 		pascalCmd := lo.PascalCase(name)
// 		structName := pascalCmd + "Options"

// 		fmt.Println("Generating struct", structName)

// 		out.WriteString("// Code generated by generate.go; DO NOT EDIT.\n")
// 		for line := range strings.SplitSeq(cmd.UsageText, "\n") {
// 			out.WriteString("// " + line + "\n")
// 		}
// 		out.WriteString("package calibredb\n\n")
// 		out.WriteString("type " + structName + " struct {\n")

// 		choices := make(map[string]string)

// 		for _, option := range cmd.Options {
// 			if len(option.Flags) == 0 {
// 				continue
// 			}
// 			columnName := loadColumnName(option)
// 			fieldName := lo.PascalCase(strings.TrimLeft(columnName, "-"))

// 			var fieldType string
// 			switch option.Type {
// 			case "string":
// 				fieldType = "string"
// 			case "int":
// 				fieldType = "int"
// 			case "float":
// 				fieldType = "float64"
// 			case "bool":
// 				fieldType = "bool"
// 			case "choice":
// 				fmt.Println(option.Choices)
// 				fieldType = fmt.Sprintf("%sChoice", fieldName)
// 				choices[fieldType] = option.Choices
// 			default:
// 				fieldType = "string"
// 			}
// 			out.WriteString(fmt.Sprintf("\t%s %s  // %s\n", fieldName, fieldType, strings.ReplaceAll(option.Help, "\n", " ")))
// 		}
// 		out.WriteString("}\n")

// 		// generate choice types
// 		for choiceType, choiceValues := range choices {
// 			out.WriteString("\n")
// 			out.WriteString(fmt.Sprintf("type %s string\n\n", choiceType))
// 			out.WriteString("const (\n")
// 			// parse choiceValues which is in format "('disabled', 'ignore', 'overwrite', 'new_record')"
// 			trimmed := strings.Trim(choiceValues, "()")
// 			split := strings.Split(trimmed, ",")
// 			for _, val := range split {
// 				cleaned := strings.Trim(val, " '\"")
// 				constName := lo.PascalCase(choiceType + "_" + cleaned)
// 				out.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, choiceType, cleaned))
// 			}
// 			out.WriteString(")\n")
// 		}
// 		out.WriteString("\n")
// 		out.WriteString("func (c *Calibre) " + pascalCmd + "Help() string {\n")
// 		out.WriteString(fmt.Sprintf("\treturn c.run(\"%s\", \"-h\")\n", name))
// 		out.WriteString("}\n")
// 		out.WriteString("\n")
// 		out.WriteString("func (c *Calibre) " + pascalCmd + "(opts " + structName + ", args ...string) string {\n")
// 		out.WriteString(fmt.Sprintf("\treturn \"%s\"\n", name))
// 		out.WriteString("}\n")

// 		err = os.WriteFile(fmt.Sprintf("calibredb/%s.go", name), out.Bytes(), 0644)
// 		if err != nil {
// 			panic(err)
// 		}
// 	}
// }

func loadColumnName(option Options) string {
	var columnName string
	flags := option.Names
	if len(flags) == 0 {
		return columnName
	}
	// if there is more than one flag, prefer the long one
	if len(flags) > 1 {
		for _, flag := range flags {
			if strings.HasPrefix(flag, "--") {
				columnName = flag
				break
			}
		}
	} else if len(flags) == 1 {
		columnName = flags[0]
	}
	return columnName
}
