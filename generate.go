//go:build ignore

// To run: go run generate.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/samber/lo"
	"github.com/veverkap/calibre-rest/calibredb"
)

func main() {
	c := calibredb.NewCalibre(calibredb.WithLibraryPath("/Users/veverkap/Code/personal/calibre-rest"))

	s := c.List(
		calibredb.ListOptions{
			Ascending:  true,
			Fields:     "author_sort, authors, comments",
			ForMachine: lo.ToPtr(false),
			Limit:      2,
		},
	)
	fmt.Println(s)
}

func generate() {
	// read calibre_cli_options.json
	jsonData, err := os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/calibredb_cli_options.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	commands := make(map[string]Command)
	err = json.Unmarshal(jsonData, &commands)
	if err != nil {
		panic(err)
	}

	for _, cmd := range commands {
		for i, option := range cmd.Options {
			if option.Type == "" {
				switch option.Default.(type) {
				case string:
					option.Type = "string"
				case int:
					option.Type = "int"
				case bool:
					option.Type = "bool"
				case float64:
					option.Type = "float"
				default:
					option.Type = "string"
				}
			}
			cmd.Options[i] = option
		}
	}

	// name := "cmd_add"
	// cmd := commands[name]
	for name, cmd := range commands {
		var out bytes.Buffer
		fmt.Println("Processing ", name)

		name = strings.Replace(name, "cmd_", "", 1)
		pascalCmd := lo.PascalCase(name)
		structName := pascalCmd + "Options"

		fmt.Println("Generating struct", structName)

		out.WriteString("// Code generated by generate.go; DO NOT EDIT.\n")
		for line := range strings.SplitSeq(cmd.UsageText, "\n") {
			out.WriteString("// " + line + "\n")
		}
		out.WriteString("package calibredb\n\n")
		out.WriteString("type " + structName + " struct {\n")

		choices := make(map[string]string)

		for _, option := range cmd.Options {
			if len(option.Flags) == 0 {
				continue
			}
			columnName := loadColumnName(option)
			fieldName := lo.PascalCase(strings.TrimLeft(columnName, "-"))

			var fieldType string
			switch option.Type {
			case "string":
				fieldType = "string"
			case "int":
				fieldType = "int"
			case "float":
				fieldType = "float64"
			case "bool":
				fieldType = "bool"
			case "choice":
				fmt.Println(option.Choices)
				fieldType = fmt.Sprintf("%sChoice", fieldName)
				choices[fieldType] = option.Choices
			default:
				fieldType = "string"
			}
			out.WriteString(fmt.Sprintf("\t%s %s  // %s\n", fieldName, fieldType, strings.ReplaceAll(option.Help, "\n", " ")))
		}
		out.WriteString("}\n")

		// generate choice types
		for choiceType, choiceValues := range choices {
			out.WriteString("\n")
			out.WriteString(fmt.Sprintf("type %s string\n\n", choiceType))
			out.WriteString("const (\n")
			// parse choiceValues which is in format "('disabled', 'ignore', 'overwrite', 'new_record')"
			trimmed := strings.Trim(choiceValues, "()")
			split := strings.Split(trimmed, ",")
			for _, val := range split {
				cleaned := strings.Trim(val, " '\"")
				constName := lo.PascalCase(choiceType + "_" + cleaned)
				out.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, choiceType, cleaned))
			}
			out.WriteString(")\n")
		}
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "Help() string {\n")
		out.WriteString(fmt.Sprintf("\treturn c.run(\"%s\", \"-h\")\n", name))
		out.WriteString("}\n")
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "(opts " + structName + ", args ...string) string {\n")
		out.WriteString(fmt.Sprintf("\treturn \"%s\"\n", name))
		out.WriteString("}\n")

		err = os.WriteFile(fmt.Sprintf("calibredb/%s.go", name), out.Bytes(), 0644)
		if err != nil {
			panic(err)
		}
	}
}

func loadColumnName(option Options) string {
	var columnName string
	flags := option.Flags
	if len(flags) == 0 {
		return columnName
	}
	// if there is more than one flag, prefer the long one
	if len(flags) > 1 {
		for _, flag := range flags {
			if strings.HasPrefix(flag, "--") {
				columnName = flag
				break
			}
		}
	} else if len(flags) == 1 {
		columnName = flags[0]
	}
	return columnName
}

type Options struct {
	Action       string   `json:"action"`
	Callback     string   `json:"callback"`
	CallbackArgs string   `json:"callback_args"`
	Choices      string   `json:"choices"`
	Default      any      `json:"default"`
	Dest         string   `json:"dest"`
	File         string   `json:"_file"`
	Flags        []string `json:"flags"`
	Help         string   `json:"help"`
	Line         int      `json:"_lineno"`
	Metavar      string   `json:"metavar"`
	Nargs        int      `json:"nargs"`
	Node         string   `json:"_node"`
	Type         string   `json:"type"`
}
type Command struct {
	File         string    `json:"file"`
	UsageText    string    `json:"usage_text"`
	Options      []Options `json:"options"`
	OptionGroups []any     `json:"option_groups"`
}
