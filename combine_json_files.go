//go:build ignore

// To run: go run generate.go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/samber/lo"
	"github.com/veverkap/calibre-rest/calibredb"
)

func main() {
	// read calibre_cli_options.json
	jsonData, err := os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/calibredb_cli_options.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	parsed := make(map[string]Command)
	err = json.Unmarshal(jsonData, &parsed)
	if err != nil {
		panic(err)
	}

	// read calibre_cli_options.json
	jsonData, err = os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/calibredb_options.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	scraped := AutoGenerated{}
	err = json.Unmarshal(jsonData, &scraped)
	if err != nil {
		panic(err)
	}

	combined := make(map[string]Combined)

	for _, cmd := range scraped.Commands {
		othername := "cmd_" + strings.ReplaceAll(cmd.Name, "-", "_")
		othercmd, ok := parsed[othername]
		if !ok {
			fmt.Println("  - Missing:", othername)
		}
		newcommands := Combined{
			Name:        cmd.Name,
			Description: cmd.Description,
			Usage:       cmd.Usage,
			Options:     make([]CombinedOptions, 0),
		}

		for _, opt := range cmd.AutoOptions {
			found := false
			for _, existingOpt := range othercmd.Options {
				for _, name := range opt.Names {

					if lo.Contains(existingOpt.Flags, name) {
						found = true
						break
					}
				}
				if found {
					newcombinedOption := CombinedOptions{
						Names:       opt.Names,
						Description: opt.Description,
						Default:     existingOpt.Default,
						Type:        existingOpt.Type,
						Choices:     existingOpt.Choices,
					}
					newcommands.Options = append(newcommands.Options, newcombinedOption)
					break
				}
			}
		}
		// let's make sure we don't have any duplicate options
		uniqueOptions := make([]CombinedOptions, 0)
		seen := make(map[string]bool)
		for _, option := range newcommands.Options {
			key := strings.Join(option.Names, ",")
			if !seen[key] {
				seen[key] = true
				uniqueOptions = append(uniqueOptions, option)
			} else {
				fmt.Println("  - Duplicate option skipped for command", cmd.Name, "option names:", option.Names)
			}
		}
		newcommands.Options = uniqueOptions
		combined[cmd.Name] = newcommands
	}

	jsonOut, err := json.MarshalIndent(combined, "", "  ")
	if err != nil {
		panic(err)
	}
	err = os.WriteFile("/Users/veverkap/Code/personal/calibre-rest/combined_calibredb_options.json", jsonOut, 0644)
	if err != nil {
		panic(err)
	}
	os.Remove("/Users/veverkap/Code/personal/calibre-rest/calibredb_cli_options.json")
	os.Remove("/Users/veverkap/Code/personal/calibre-rest/calibredb_options.json")
}

func test() {
	c := calibredb.NewCalibre(calibredb.WithLibraryPath("/Users/veverkap/Code/personal/calibre-rest"))

	s := c.List(
		calibredb.ListOptions{
			Ascending:  true,
			Fields:     "author_sort, authors, comments",
			ForMachine: lo.ToPtr(false),
			Limit:      2,
		},
	)
	fmt.Println(s)
}

type Options struct {
	Action       string   `json:"action"`
	Callback     string   `json:"callback"`
	CallbackArgs string   `json:"callback_args"`
	Choices      string   `json:"choices"`
	Default      any      `json:"default"`
	Dest         string   `json:"dest"`
	File         string   `json:"_file"`
	Flags        []string `json:"flags"`
	Help         string   `json:"help"`
	Line         int      `json:"_lineno"`
	Metavar      string   `json:"metavar"`
	Nargs        int      `json:"nargs"`
	Node         string   `json:"_node"`
	Type         string   `json:"type"`
}
type Command struct {
	File         string    `json:"file"`
	UsageText    string    `json:"usage_text"`
	Options      []Options `json:"options"`
	OptionGroups []any     `json:"option_groups"`
}

type AutoGenerated struct {
	GlobalOptions []GlobalOptions `json:"global_options"`
	Commands      []Commands      `json:"commands"`
}
type GlobalOptions struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
}
type AutoOptions struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
	Default     any      `json:"default"`
	Type        string   `json:"type"`
}
type Commands struct {
	Name        string        `json:"name"`
	ID          string        `json:"id"`
	Description string        `json:"description"`
	Usage       string        `json:"usage"`
	AutoOptions []AutoOptions `json:"options"`
	Title       string        `json:"title"`
}

type CombinedOptions struct {
	Names       []string `json:"names,omitempty"`
	Description string   `json:"description,omitempty"`
	Default     any      `json:"default,omitempty"`
	Type        string   `json:"type,omitempty"`
	Choices     string   `json:"choices,omitempty"`
}
type Combined struct {
	Name        string            `json:"name"`
	Description string            `json:"description"`
	Usage       string            `json:"usage"`
	Options     []CombinedOptions `json:"options"`
}
