//go:build ignore

// To run: go run generate.go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"slices"
	"strings"

	"github.com/samber/lo"
)

func main() {
	// read calibre_cli_options.json
	jsonData, err := os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/parsed.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	parsed := make(map[string]Command)
	err = json.Unmarshal(jsonData, &parsed)
	if err != nil {
		panic(err)
	}

	// read calibre_cli_options.json
	jsonData, err = os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/scraped.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	scraped := AutoGenerated{}
	err = json.Unmarshal(jsonData, &scraped)
	if err != nil {
		panic(err)
	}

	combined := make(map[string]Combined)

	for _, cmd := range scraped.Commands {
		othername := "cmd_" + strings.ReplaceAll(cmd.Name, "-", "_")
		othercmd, ok := parsed[othername]
		if !ok {
			fmt.Println("  - Missing:", othername)
		}
		newcommands := Combined{
			Name:        cmd.Name,
			Description: cmd.Description,
			Usage:       cmd.Usage,
			Options:     make([]CombinedOptions, 0),
			Args:        make([]Arguments, 0),
		}

		for _, opt := range cmd.AutoOptions {
			found := false
			for _, existingOpt := range othercmd.Options {
				for _, name := range opt.Names {

					if lo.Contains(existingOpt.Flags, name) {
						found = true
						break
					}
				}
				if found {
					newcombinedOption := CombinedOptions{
						Names:       opt.Names,
						Description: opt.Description,
						Default:     existingOpt.Default,
						Type:        existingOpt.Type,
						Choices:     existingOpt.Choices,
					}
					newcommands.Options = append(newcommands.Options, newcombinedOption)
					break
				}
			}
		}
		// let's make sure we don't have any duplicate options
		uniqueOptions := make([]CombinedOptions, 0)
		seen := make(map[string]bool)
		for _, option := range newcommands.Options {
			key := strings.Join(option.Names, ",")
			if !seen[key] {
				seen[key] = true
				uniqueOptions = append(uniqueOptions, option)
			} else {
				fmt.Println("  - Duplicate option skipped for command", cmd.Name, "option names:", option.Names)
			}
		}
		newcommands.Options = uniqueOptions
		combined[cmd.Name] = newcommands
	}

	updatedcombined := make(map[string]Combined)
	for _, cmd := range combined {
		for i, option := range cmd.Options {
			if option.Type == "" {
				if option.Default == "[]" {
					option.Type = "[]string"
					cmd.Options[i] = option
					continue
				}
				if option.Choices != "" {
					option.Type = "choice"
					cmd.Options[i] = option
					continue
				}
				switch option.Default.(type) {
				case string:
					option.Type = "string"
				case int:
					option.Type = "int"
				case bool:
					option.Type = "bool"
				case float64:
					option.Type = "float"
				case nil:
					option.Type = "string"
				default:
					fmt.Println("Could not figure out ", option.Default)
					option.Type = "string"
				}
			}
			cmd.Options[i] = option
		}
		arguments := strings.Split(cmd.Usage, " ")

		// we do not care about the first argument calibredb or the second argument which is the command name
		if len(arguments) > 2 {
			// if one of the arguments is "..." this means it is a variadic argument like `file1 file2 file3 ...`
			if slices.Contains(arguments[2:], "...") {
				newoption := Arguments{
					Name: "files",
					Type: "[]string",
				}
				cmd.Args = append(cmd.Args, newoption)
			} else {
				// otherwise we add all arguments one by one
				for _, arg := range arguments[2:] {
					if arg == "[options]" {
						// we skip over this since we already have options parsed
						continue
					}
					if arg == "(list|add|remove)" {
						continue
					}
					if strings.Contains(arg, "path/to") {
						newoption := Arguments{
							Name: "path",
							Type: "string",
						}
						cmd.Args = append(cmd.Args, newoption)
						continue
					}
					// check if the whole word "comma" is in the description
					re := regexp.MustCompile(`\bcomma\b`)
					if re.MatchString(cmd.Description) && arg == "ids" {
						newoption := Arguments{
							Name: arg,
							Type: "[]string",
						}
						cmd.Args = append(cmd.Args, newoption)
					} else {
						newoption := Arguments{
							Name: arg,
							Type: "string",
						}
						cmd.Args = append(cmd.Args, newoption)
					}
				}
			}
		}
		updatedcombined[cmd.Name] = cmd
	}

	jsonOut, err := json.MarshalIndent(updatedcombined, "", "  ")
	if err != nil {
		panic(err)
	}
	jsonOut, err := json.MarshalIndent(updatedcombined, "", "  ")
	if err != nil {
		panic(err)
	}
	// Determine output path: command-line argument, environment variable, or default
	outputPath := "./combined_calibredb_options.json"
	if envPath := os.Getenv("OUTPUT_PATH"); envPath != "" {
		outputPath = envPath
	}
	if len(os.Args) > 1 {
		outputPath = os.Args[1]
	}
	fmt.Printf("Writing output to: %s\n", outputPath)
	err = os.WriteFile(outputPath, jsonOut, 0644)
	if err != nil {
		panic(err)
	}
}

type Options struct {
	Action       string   `json:"action"`
	Callback     string   `json:"callback"`
	CallbackArgs string   `json:"callback_args"`
	Choices      string   `json:"choices"`
	Default      any      `json:"default"`
	Dest         string   `json:"dest"`
	File         string   `json:"_file"`
	Flags        []string `json:"flags"`
	Help         string   `json:"help"`
	Line         int      `json:"_lineno"`
	Metavar      string   `json:"metavar"`
	Nargs        int      `json:"nargs"`
	Node         string   `json:"_node"`
	Type         string   `json:"type"`
}
type Command struct {
	File         string    `json:"file"`
	UsageText    string    `json:"usage_text"`
	Options      []Options `json:"options"`
	OptionGroups []any     `json:"option_groups"`
}

type AutoGenerated struct {
	GlobalOptions []GlobalOptions `json:"global_options"`
	Commands      []Commands      `json:"commands"`
}
type GlobalOptions struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
}
type AutoOptions struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
	Default     any      `json:"default"`
	Type        string   `json:"type"`
}
type Commands struct {
	Name        string        `json:"name"`
	ID          string        `json:"id"`
	Description string        `json:"description"`
	Usage       string        `json:"usage"`
	AutoOptions []AutoOptions `json:"options"`
	Title       string        `json:"title"`
}

type CombinedOptions struct {
	Names       []string `json:"names,omitempty"`
	Description string   `json:"description,omitempty"`
	Default     any      `json:"default,omitempty"`
	Type        string   `json:"type,omitempty"`
	Choices     string   `json:"choices,omitempty"`
}

type Arguments struct {
	Name    string   `json:"name,omitempty"`
	Type    string   `json:"type,omitempty"`
	Choices []string `json:"choices,omitempty"`
}
type Combined struct {
	Name        string            `json:"name"`
	Description string            `json:"description"`
	Usage       string            `json:"usage"`
	Options     []CombinedOptions `json:"options"`
	Args        []Arguments       `json:"args,omitempty"`
}
