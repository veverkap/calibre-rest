//go:build ignore

// To run: go run generate.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/samber/lo"
	"github.com/veverkap/calibre-rest/calibredb"
)

func main() {
	// read calibre_cli_options.json
	jsonData, err := os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/calibredb_cli_options.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	parsed := make(map[string]Command)
	err = json.Unmarshal(jsonData, &parsed)
	if err != nil {
		panic(err)
	}

	// read calibre_cli_options.json
	jsonData, err = os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/calibredb_options.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	scraped := AutoGenerated{}
	err = json.Unmarshal(jsonData, &scraped)
	if err != nil {
		panic(err)
	}

	combined := make(map[string]Combined)

	for _, cmd := range scraped.Commands {
		othername := "cmd_" + strings.ReplaceAll(cmd.Name, "-", "_")
		othercmd, ok := parsed[othername]
		if !ok {
			fmt.Println("  - Missing:", othername)
		}
		newcommands := Combined{
			Name:        cmd.Name,
			Description: cmd.Description,
			Usage:       cmd.Usage,
			Options:     make([]CombinedOptions, 0),
		}

		for _, opt := range cmd.AutoOptions {
			found := false
			for _, existingOpt := range othercmd.Options {
				for _, name := range opt.Names {

					if lo.Contains(existingOpt.Flags, name) {
						found = true
						break
					}
				}
				if found {
					newcombinedOption := CombinedOptions{
						Names:       opt.Names,
						Description: opt.Description,
						Default:     existingOpt.Default,
						Type:        existingOpt.Type,
						Choices:     existingOpt.Choices,
					}
					newcommands.Options = append(newcommands.Options, newcombinedOption)
					break
				}
			}
		}
		// let's make sure we don't have any duplicate options
		uniqueOptions := make([]CombinedOptions, 0)
		seen := make(map[string]bool)
		for _, option := range newcommands.Options {
			key := strings.Join(option.Names, ",")
			if !seen[key] {
				seen[key] = true
				uniqueOptions = append(uniqueOptions, option)
			} else {
				fmt.Println("  - Duplicate option skipped for command", cmd.Name, "option names:", option.Names)
			}
		}
		newcommands.Options = uniqueOptions
		combined[cmd.Name] = newcommands
	}

	jsonOut, err := json.MarshalIndent(combined, "", "  ")
	if err != nil {
		panic(err)
	}
	err = os.WriteFile("/Users/veverkap/Code/personal/calibre-rest/combined_calibredb_options.json", jsonOut, 0644)
	if err != nil {
		panic(err)
	}
	os.Remove("/Users/veverkap/Code/personal/calibre-rest/calibredb_cli_options.json")
	os.Remove("/Users/veverkap/Code/personal/calibre-rest/calibredb_options.json")
}

func test() {
	c := calibredb.NewCalibre(calibredb.WithLibraryPath("/Users/veverkap/Code/personal/calibre-rest"))

	s := c.List(
		calibredb.ListOptions{
			Ascending:  true,
			Fields:     "author_sort, authors, comments",
			ForMachine: lo.ToPtr(false),
			Limit:      2,
		},
	)
	fmt.Println(s)
}

func generate() {
	// read calibre_cli_options.json
	jsonData, err := os.ReadFile("/Users/veverkap/Code/personal/calibre-rest/calibredb_cli_options.json")
	if err != nil {
		panic(err)
	}
	// unmarshal jsonData into map[string]Command
	commands := make(map[string]Command)
	err = json.Unmarshal(jsonData, &commands)
	if err != nil {
		panic(err)
	}

	for _, cmd := range commands {
		for i, option := range cmd.Options {
			if option.Type == "" {
				switch option.Default.(type) {
				case string:
					option.Type = "string"
				case int:
					option.Type = "int"
				case bool:
					option.Type = "bool"
				case float64:
					option.Type = "float"
				default:
					option.Type = "string"
				}
			}
			cmd.Options[i] = option
		}
	}

	// name := "cmd_add"
	// cmd := commands[name]
	for name, cmd := range commands {
		var out bytes.Buffer
		fmt.Println("Processing ", name)

		name = strings.Replace(name, "cmd_", "", 1)
		pascalCmd := lo.PascalCase(name)
		structName := pascalCmd + "Options"

		fmt.Println("Generating struct", structName)

		out.WriteString("// Code generated by generate.go; DO NOT EDIT.\n")
		for line := range strings.SplitSeq(cmd.UsageText, "\n") {
			out.WriteString("// " + line + "\n")
		}
		out.WriteString("package calibredb\n\n")
		out.WriteString("type " + structName + " struct {\n")

		choices := make(map[string]string)

		for _, option := range cmd.Options {
			if len(option.Flags) == 0 {
				continue
			}
			columnName := loadColumnName(option)
			fieldName := lo.PascalCase(strings.TrimLeft(columnName, "-"))

			var fieldType string
			switch option.Type {
			case "string":
				fieldType = "string"
			case "int":
				fieldType = "int"
			case "float":
				fieldType = "float64"
			case "bool":
				fieldType = "bool"
			case "choice":
				fmt.Println(option.Choices)
				fieldType = fmt.Sprintf("%sChoice", fieldName)
				choices[fieldType] = option.Choices
			default:
				fieldType = "string"
			}
			out.WriteString(fmt.Sprintf("\t%s %s  // %s\n", fieldName, fieldType, strings.ReplaceAll(option.Help, "\n", " ")))
		}
		out.WriteString("}\n")

		// generate choice types
		for choiceType, choiceValues := range choices {
			out.WriteString("\n")
			out.WriteString(fmt.Sprintf("type %s string\n\n", choiceType))
			out.WriteString("const (\n")
			// parse choiceValues which is in format "('disabled', 'ignore', 'overwrite', 'new_record')"
			trimmed := strings.Trim(choiceValues, "()")
			split := strings.Split(trimmed, ",")
			for _, val := range split {
				cleaned := strings.Trim(val, " '\"")
				constName := lo.PascalCase(choiceType + "_" + cleaned)
				out.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, choiceType, cleaned))
			}
			out.WriteString(")\n")
		}
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "Help() string {\n")
		out.WriteString(fmt.Sprintf("\treturn c.run(\"%s\", \"-h\")\n", name))
		out.WriteString("}\n")
		out.WriteString("\n")
		out.WriteString("func (c *Calibre) " + pascalCmd + "(opts " + structName + ", args ...string) string {\n")
		out.WriteString(fmt.Sprintf("\treturn \"%s\"\n", name))
		out.WriteString("}\n")

		err = os.WriteFile(fmt.Sprintf("calibredb/%s.go", name), out.Bytes(), 0644)
		if err != nil {
			panic(err)
		}
	}
}

func loadColumnName(option Options) string {
	var columnName string
	flags := option.Flags
	if len(flags) == 0 {
		return columnName
	}
	// if there is more than one flag, prefer the long one
	if len(flags) > 1 {
		for _, flag := range flags {
			if strings.HasPrefix(flag, "--") {
				columnName = flag
				break
			}
		}
	} else if len(flags) == 1 {
		columnName = flags[0]
	}
	return columnName
}

type Options struct {
	Action       string   `json:"action"`
	Callback     string   `json:"callback"`
	CallbackArgs string   `json:"callback_args"`
	Choices      string   `json:"choices"`
	Default      any      `json:"default"`
	Dest         string   `json:"dest"`
	File         string   `json:"_file"`
	Flags        []string `json:"flags"`
	Help         string   `json:"help"`
	Line         int      `json:"_lineno"`
	Metavar      string   `json:"metavar"`
	Nargs        int      `json:"nargs"`
	Node         string   `json:"_node"`
	Type         string   `json:"type"`
}
type Command struct {
	File         string    `json:"file"`
	UsageText    string    `json:"usage_text"`
	Options      []Options `json:"options"`
	OptionGroups []any     `json:"option_groups"`
}

type AutoGenerated struct {
	GlobalOptions []GlobalOptions `json:"global_options"`
	Commands      []Commands      `json:"commands"`
}
type GlobalOptions struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
}
type AutoOptions struct {
	Names       []string `json:"names"`
	Description string   `json:"description"`
	Default     any      `json:"default"`
	Type        string   `json:"type"`
}
type Commands struct {
	Name        string        `json:"name"`
	ID          string        `json:"id"`
	Description string        `json:"description"`
	Usage       string        `json:"usage"`
	AutoOptions []AutoOptions `json:"options"`
	Title       string        `json:"title"`
}

type CombinedOptions struct {
	Names       []string `json:"names,omitempty"`
	Description string   `json:"description,omitempty"`
	Default     any      `json:"default,omitempty"`
	Type        string   `json:"type,omitempty"`
	Choices     string   `json:"choices,omitempty"`
}
type Combined struct {
	Name        string            `json:"name"`
	Description string            `json:"description"`
	Usage       string            `json:"usage"`
	Options     []CombinedOptions `json:"options"`
}
