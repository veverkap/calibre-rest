// Code generated by generate.go; DO NOT EDIT.
//
// Command:
// calibredb fts_search [options] search expression
//
// Description:
// Do a full text search on the entire library or a subset of it.

package calibredb

type FtsSearchOptions struct {
	// Command Line Arguments
	Search string  `validate:"required"`
	Expression string  `validate:"required"`

	// Command Line Options
	DoNotMatchOnRelatedWords *bool  // Only match on exact words not related words. So correction will not match correcting.
	IncludeSnippets *bool  // Include snippets of the text surrounding each match. Note that this makes searching much slower.
	IndexingThreshold float64  // How much of the library must be indexed before searching is allowed, as a percentage. Defaults to 90
	MatchEndMarker string  // The marker used to indicate the end of a matched word inside a snippet
	MatchStartMarker string  // The marker used to indicate the start of a matched word inside a snippet
	OutputFormat OutputFormatChoice  // The format to output the search results in. Either " text " for plain text or " json " for JSON output.
	RestrictTo string  // Restrict the searched books, either using a search expression or ids. For example: ids:1,2,3 to restrict by ids or search:tag:foo to restrict to books having the tag foo.
}

type OutputFormatChoice string

const (
	Text OutputFormatChoice = "text"
	Json OutputFormatChoice = "json"
)

func (c *Calibre) FtsSearchHelp() string {
	if out, err := c.run("fts_search", "-h"); err != nil {
		return err.Error()
	} else {
		return out
	}
}

func (c *Calibre) FtsSearch(opts FtsSearchOptions, args ...string) (string, error) {
	argv := []string{"fts_search"}

	// validate the command line arguments
	err := c.validate.Struct(opts)
	if err != nil {
		return "", err
	}
	// Command Line Arguments
	argv = append(argv, opts.Search)
	argv = append(argv, opts.Expression)

	// Command Line Options
	// Handling bool
	if opts.DoNotMatchOnRelatedWords != nil && *opts.DoNotMatchOnRelatedWords {
		argv = append(argv, "--do-not-match-on-related-words")
	}
	// Handling bool
	if opts.IncludeSnippets != nil && *opts.IncludeSnippets {
		argv = append(argv, "--include-snippets")
	}
	// Handling other float
	// Handling string
	if opts.MatchEndMarker != "" {
		argv = append(argv, "--match-end-marker", opts.MatchEndMarker)
	}
	// Handling string
	if opts.MatchStartMarker != "" {
		argv = append(argv, "--match-start-marker", opts.MatchStartMarker)
	}
	// Handling other choice
	// Handling string
	if opts.RestrictTo != "" {
		argv = append(argv, "--restrict-to", opts.RestrictTo)
	}
	out, err := c.run(argv...)
	return out, err
}
